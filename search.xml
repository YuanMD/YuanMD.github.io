<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/2023/04/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h1><h2 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h2><ul><li><p>变量定义的一般形式就是：</p><ul><li>&lt;类型名称&gt; &lt;变量名称&gt;;</li></ul></li><li><p>变量需要一个名字，变量的名字是一种“标识符”，意思是它是用来识别这个和那个的不同的名字。</p></li><li><p>标识符有标识符的构造规则。基本的原则是：标识符只能由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线</strong>组成，数字不可以出现在第一个位置上，C语言的关键字（有的地方叫它们保留字）不可以用做标识符。</p></li><li><p>所有变量在第一次被使用（出现在赋值运算符的右边）之前应该被赋值一次。</p></li><li><p>C是一种有类型的语言，所有的变量在使用之前必须<strong>定义</strong>或<strong>声明</strong>，所有的变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。</p></li></ul><h2 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> AMOUNT = <span class="number">100</span></span><br><span class="line">    <span class="type">int</span> price = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;price);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> change = AMOUNT - price;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找您%d元\n&quot;</span>, change);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>固定不变的数，是常数。直接写在程序里，我们称作直接量（literal）</p></li><li><p>更好的方式，是定义一个常量：</p><ul><li><code>const int AMOUNT = 100</code>;</li></ul></li><li><p><code>const</code>是一个修饰符，加在int的前面，用来给这个变量加上一个const（不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了。</p></li><li><p>如果你试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误。</p></li></ul><h2 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3 浮点数"></a>1.3 浮点数</h2><ul><li>带小数点的数值。浮点这个词的本意就是指小数点是浮动的，是计算机内部表达非整数（包含分数和无理数）的一种方式。</li><li>当浮点数和整数放到一起运算时，C会将整数转换成<strong>浮点数</strong>，然后进行浮点数的运算。</li></ul><h2 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h2><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">运算</th><th align="center">结合关系</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">+</td><td align="center">单目不变</td><td align="center">自右向左</td><td align="center">a*+b</td></tr><tr><td align="center">1</td><td align="center">-</td><td align="center">单目取负</td><td align="center">自右向左</td><td align="center">a*-b</td></tr><tr><td align="center">2</td><td align="center">*</td><td align="center">乘</td><td align="center">自左向右</td><td align="center">a*b</td></tr><tr><td align="center">2</td><td align="center">&#x2F;</td><td align="center">除</td><td align="center">自左向右</td><td align="center">a&#x2F;b</td></tr><tr><td align="center">2</td><td align="center">%</td><td align="center">取余</td><td align="center">自左向右</td><td align="center">a%b</td></tr><tr><td align="center">3</td><td align="center">+</td><td align="center">加</td><td align="center">自左向右</td><td align="center">a+b</td></tr><tr><td align="center">3</td><td align="center">-</td><td align="center">减</td><td align="center">自左向右</td><td align="center">a-b</td></tr><tr><td align="center">4</td><td align="center">&#x3D;</td><td align="center">赋值</td><td align="center">自右向左</td><td align="center">a&#x3D;b</td></tr></tbody></table><h2 id="1-5-关系运算"><a href="#1-5-关系运算" class="headerlink" title="1.5 关系运算"></a>1.5 关系运算</h2><ul><li>所有的关系运算符的优先级比算术运算的低，但是比赋值运算的高。</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">相等</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不相等</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于或等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于或等于</td></tr></tbody></table><h1 id="2-判断"><a href="#2-判断" class="headerlink" title="2 判断"></a>2 判断</h1><h2 id="2-1-多路分支switch-case"><a href="#2-1-多路分支switch-case" class="headerlink" title="2.1 多路分支switch-case"></a>2.1 多路分支switch-case</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (控制表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">case</span> 常量:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    语句    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制表达式只能是<strong>整数</strong>类型的结果</li><li>常量可以是常数，也可以是常数计算的表达式</li></ul><h2 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h2><ul><li><p>循环体内要有改变条件的机会</p></li><li><p>for(初始动作；条件；每轮的动作) { }</p><ul><li>for中的每一个表达式都是可以省略的</li><li>for(；条件；) &#x3D;&#x3D; while(条件)</li></ul></li><li><p>如果有固定次数，用for</p></li><li><p>如果必须执行一次，用do_while</p></li><li><p>其他情况用while</p></li></ul><h1 id="3-数据"><a href="#3-数据" class="headerlink" title="3 数据"></a>3 数据</h1><h2 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h2><ul><li>所表达的数的范围：char &lt; short &lt; int &lt; float &lt; double</li></ul><h3 id="3-1-1-sizeof"><a href="#3-1-1-sizeof" class="headerlink" title="3.1.1 sizeof"></a>3.1.1 sizeof</h3><ul><li><p>sizeof是一个运算符，给出某个类型或变量在内存中所占的字节数</p><ul><li><code>sizeof(int)</code></li><li><code>sizeof(i)</code></li></ul></li><li><p>是<strong>静态运算符</strong>，它的结果在编译时刻就决定了</p></li><li><p>不要在sizeof的括号里做运算，这些运算不会做的</p></li></ul><h3 id="3-1-2-整数"><a href="#3-1-2-整数" class="headerlink" title="3.1.2 整数"></a>3.1.2 整数</h3><ul><li><p>char：1字节（8比特）-128 ~ 127</p></li><li><p>short：2字节 -32768 ~ 32767</p></li><li><p>int：取决于编译器（CPU）,通常的意义是“1个字”</p></li><li><p>long：取决于编译器（CPU）,通常的意义是“1个字”</p></li><li><p>long long：8字节</p></li><li><p>为什么整数要有那么多种？</p><ul><li>为了准确表达内存，做底层程序的需要</li></ul></li><li><p>没有特殊需要，就选择int</p><ul><li>现在CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢</li><li>*现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)</li></ul></li><li><p>unsigned与否只是输出的不同，内部计算是一样的</p></li></ul><h3 id="3-1-3-unsigned"><a href="#3-1-3-unsigned" class="headerlink" title="3.1.3 unsigned"></a>3.1.3 unsigned</h3><ul><li><p>如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U</p><ul><li><code>255U</code></li></ul></li><li><p>用l或L表示long(long)</p></li><li><p>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</p></li></ul><h3 id="3-1-4-浮点数"><a href="#3-1-4-浮点数" class="headerlink" title="3.1.4 浮点数"></a>3.1.4 浮点数</h3><ul><li>printf输出inf表示<strong>超过范围</strong>的浮点数：±∞</li><li>printf输出nan表示<strong>不存在</strong>的浮点数</li></ul><p>运算精度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">1.345f</span>;</span><br><span class="line">    b = <span class="number">1.123f</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">2.468</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不相等! c=%.10f,或%f\n&quot;</span>,c, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带小数点的字面量是double而非float</li><li>float需要用f或F后缀来表明身份</li><li><code>f1 == f2</code>可能失败<ul><li><code>fabs(f1-f2) &lt; 1e-12</code></li></ul></li></ul><p>浮点类型选择</p><ul><li>如果没有特殊需要，只是用double</li><li>现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</li></ul><h3 id="3-1-5-bool"><a href="#3-1-5-bool" class="headerlink" title="3.1.5 bool"></a>3.1.5 bool</h3><ul><li><code>#include &lt;stdbool.h&gt;</code></li><li>之后就可以使用bool和true、false</li></ul><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h2><ul><li><p>当运算符的两边出现不一致的类型时，会自动转换成较大的类型</p><ul><li>大的意思是能表达的数的范围更大</li><li>char—&gt;short—&gt;int—&gt;long—&gt;long long</li><li>int—&gt;float—&gt;double</li></ul></li><li><p>对于printf，任何小于int的类型会被转换成int；float会被转换成double</p></li><li><p>但是scanf不会，要输入short，需要%hd</p></li><li><p>要把一个量强制转换成另一个类型（通常是较小的类型），需要：（类型）值</p></li><li><p>注意这时候的安全性，小的变量不总能表达大的量</p><ul><li><code>(short)32768</code></li></ul></li><li><p>只是从那个变量计算出了一个<strong>新的类型的值</strong>，它并不改变那个变量，无论是值还是类型都不改变</p></li></ul><h2 id="3-3-逻辑运算"><a href="#3-3-逻辑运算" class="headerlink" title="3.3 逻辑运算"></a>3.3 逻辑运算</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">逻辑非</td><td align="center">!a</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td><td align="center">a&amp;&amp;b</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td><td align="center">a||b</td></tr></tbody></table><h3 id="3-3-1-优先级"><a href="#3-3-1-优先级" class="headerlink" title="3.3.1 优先级"></a>3.3.1 优先级</h3><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">()</td><td align="center">从左到右</td></tr><tr><td align="center">2</td><td align="center">! + - ++ –</td><td align="center">从右到左</td></tr><tr><td align="center">3</td><td align="center">* &#x2F; %</td><td align="center">从左到右</td></tr><tr><td align="center">4</td><td align="center">+ -</td><td align="center">从左到右</td></tr><tr><td align="center">5</td><td align="center">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td align="center">从左到右</td></tr><tr><td align="center">6</td><td align="center">&#x3D;&#x3D; !&#x3D;</td><td align="center">从左到右</td></tr><tr><td align="center">7</td><td align="center">&amp;&amp;</td><td align="center">从左到右</td></tr><tr><td align="center">8</td><td align="center">||</td><td align="center">从左到右</td></tr><tr><td align="center">9</td><td align="center">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</td><td align="center">从右到左</td></tr></tbody></table><h3 id="3-3-2-短路"><a href="#3-3-2-短路" class="headerlink" title="3.3.2 短路"></a>3.3.2 短路</h3><ul><li><p>逻辑运算是自左向右进行的，<strong>如果左边的结果已经能够决定结果了，就不会做右边的计算</strong></p><ul><li><code>a==6 &amp;&amp; b==1</code></li><li><code>a==6 &amp;&amp; b+=1</code></li></ul></li><li><p>对于&amp;&amp;，左边是false时就不做右边了</p></li><li><p>对于||，左边是true时就不做右边了</p></li><li><p>&#x3D;&#x3D;不要把赋值，包括复合赋值组合进表达式&#x3D;&#x3D;</p></li></ul><h2 id="3-4-条件运算符"><a href="#3-4-条件运算符" class="headerlink" title="3.4 条件运算符"></a>3.4 条件运算符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = (count &gt; <span class="number">20</span>)?count<span class="number">-10</span>:count+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">20</span>)</span><br><span class="line">    count = count - <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    count = count + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>条件运算符额优先级高于赋值运算符，但是低于其他运算符</li></ul><h3 id="3-4-1-逗号运算符"><a href="#3-4-1-逗号运算符" class="headerlink" title="3.4.1 逗号运算符"></a>3.4.1 逗号运算符</h3><ul><li>逗号用来连接两个表达式，并以其<strong>右边</strong>的表达式的值作为它的<strong>结果</strong>。逗号的优先级是所有的运算符中<strong>最低</strong>的，所以它两边的表达式会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">3</span>+<span class="number">4</span>,<span class="number">5</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for中使用</p><ul><li><code>for(i=0 , j=10 ; i&lt;j ; i++ , j-- )</code></li></ul><h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=begin; i&lt;=end; i++)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d到%d的和是%d\n&quot;</span>, begin, end, sum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    sum(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    sum(<span class="number">35</span>, <span class="number">45</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样把sum()写在上面，是因为：C的编译器<strong>自上而下</strong>顺序分析你的代码</p><ul><li>在看到<code>sum(1, 10)</code>的时候，它需要知道sum()的样子，也就是sum()要几个参数，每个参数的类型如何，返回什么类型，这样它才能检查你对sum()的调用是否正确。</li></ul><h2 id="4-1-参数传递"><a href="#4-1-参数传递" class="headerlink" title="4.1 参数传递"></a>4.1 参数传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cheer</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cheer %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    cheer(<span class="number">2.4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞</li><li>编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t=a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C语言在调用函数时，永远只能传值给函数</li><li>每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</li></ul><h2 id="4-2-本地-局部-变量"><a href="#4-2-本地-局部-变量" class="headerlink" title="4.2 本地(局部)变量"></a>4.2 本地(局部)变量</h2><ul><li><p>函数的每次运行，就产生了一个独立的变量空间，在这个空间中变量，是函数的这次运行所独有的，称作本地变量</p></li><li><p>定义在函数内部变量就是本地变量，<strong>参数</strong>也是本地变量</p></li><li><p>本地变量是定义在块内的</p><ul><li>它可以是定义在<strong>函数的块内</strong></li><li>也可以定义在<strong>语句的块内</strong></li><li>甚至可以随便拉一对大括号来定义变量</li></ul></li><li><p>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</p></li><li><p>块外面定义的变量在里面仍然有效</p></li><li><p>块里面定义了和外面同名的变量则<strong>掩盖了外面</strong>的</p></li><li><p>不能在一个块内定义同名的变量</p></li><li><p>本地变量<strong>不会被默认初始化</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">6</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h1><ul><li>其中所有的元素具有相同的数据类型</li><li>一旦创建，不能改变大小</li><li>*数组中的元素在内存中是<strong>连续依次</strong>排列的</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
