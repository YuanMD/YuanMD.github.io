<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刺客信条</title>
      <link href="/2023/05/16/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/"/>
      <url>/2023/05/16/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>刺客信条系列育碧的经典大作，其背后宏大的世界观让人细思极恐。目前游戏内的时间跨度已达到 7 万多年，从最早地球上出现的先行者，直到 2020 年的蕾拉。在这个系列的每一部剧情内，育碧都在历史的夹缝中植入了大量关于刺客与圣殿骑士的阴谋论，但这也容易导致玩家对历史产生疑问，于是育碧开始在后续的游戏中加入了发现之旅模式，这可以让玩家们跟随由历史学家和考古学者讲解的导览，去学习和了解更多与之相关的真实历史与人文故事。</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>伊述，地球上最早出现的远古文明。每一个伊述人都拥有高度发达的智力，他们的基因拥有三螺旋 DNA 结构，并且还拥有第六感“知识”。而在伊述的发展过程中，他们意识到了劳动力的严重不足，于是伊述人根据自己的相貌创造出了拥有双螺旋 DNA 结构的人类，并在人类的神经中加入了某种特殊的神经递质，说白了就是给人类安装了一个接收器，而伊述人可以通过伊甸碎片——金苹果，发射某种控制信号，这样就能保证人类被完全掌控。</p><p>可在接下来的日子里，部分伊述人却与人类产生了结合，诞下了许多混血儿。而这些混血儿以及他们的后代身上都或多或少拥有伊述人的DNA，而那些伊述 DNA 浓度较高的人类，甚至可以摆脱金苹果的控制。除此之外，这些强大的混血儿后代还拥有两个特殊能力，既第六感就是我们在游戏中常用的鹰眼视觉，刺客信条所有主角都可以使用这项特殊技能，只是施展的方式有稍许不同。比如在起源与奥德赛这两部作品中，主角则是通过鹰的视角来采集信息，另外一项就是自由奔跑，但这项能力也可以通过后天训练习得。</p><p>但就在巨灾来临的前一刻，不少伊述族群的领袖想出了新的存活方法。以阿萨族群的首领奥丁为例，他将自己的意识输入进了名为世界树的超级计算机，并且将自己的基因序列融入到了人类的基因中，希望后世某个拥有奥丁基因的人类能够觉醒他的记忆与人格，那样奥丁就会与当事人融合。</p><p>除了奥丁外，还有几名伊述的重要人物也采用了这个方法，他们都希望有朝一日可以重回于世。多峇巨灾终于降临，太阳耀斑的爆发几乎灭绝了伊述与人类。日冕物质颠倒了地球磁场的南北极，而地球也陷入一片火海，大火足足燃烧了数周之久，最终地球表面化为了一片炙热的荒原，只有不到一万的人类与极少数的伊述人存活了下来。双方为了这个共同的家园最终达成了和解，并开始为恢复地球的生机而共同奋斗。</p><p>一些伊述科学家开始了灾后重建和预防工作，早在灾难之前，他们就在世界各地修建了神殿。现在这些遍布全球的神殿将分析结果传输至如今位于纽约北部的“大神殿”。伊述人希望以此来避免下一次灾难的发生，但也有一部分伊述至上主义者还在想方设法奴役人类。公元前 74900 年，随着最后一名伊述人的去世，人类终于成为了地球唯一的主人。</p><p>在经历了漫长的岁月后，如今的地球早已重新焕发了生机，但只有少数人知道，这颗星球还有另外一个文明存在过，这小部分人称呼伊述为“先行者”，或者是“第一文明”、“”更早到来之人“等等。而对于绝大多数人来讲，伊述人的文化与故事以及社会结构，在漫长的历史演变中逐渐变成了传说，乃至最后变成了所谓的”神“。至于伊述人留下的伊甸碎片以及伊甸科技，则散落在全球的各个角落。而那些伊述与人类的混血后代，也都将在未来的历史长河中扮演重要角色。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>公元前 1334 年，埃及法老斯门卡瑞创建了上古维序者，又称圣蛇，即圣殿骑士组织的前身。早期上古维序者们一直在努力寻找伊述文明的遗物，而他们最早的初衷是想利用这些”远古神明“的遗物，让世界在他们有秩序的统治下为人类带来和平与进步。随着上古维序者在埃及的不断壮大，他们将目光随即转向了波斯，并企图暗中控制阿契美尼德王朝的诸位皇帝。</p><p>公元前 525 年，人类的贪婪以及对权力的渴望，让上古维序者的美好初衷在后续的传承中逐渐偏离了轨道，甚至走向了极端。在这八百年中，我只能推测，也许是上古维序者出现了分裂，也许是后期的埃及统治者违背了他们的意志，或许是其他种种原因，总之，作为上古维序者新盟友的波斯帝国全面侵占了埃及，从此埃及也被并进了波斯的版图。</p><p>公元前 485 年，作为上古维序者的“新傀儡”，波斯王薛西斯一世正用他残暴的方式统治着庞大的波斯帝国，而且他还纵情酒色，亲近小人，这也导致波斯帝国内乱不断。不止如此，这位暴君还持续着对希腊的入侵。公元前 480 年，斯巴达国王列奥尼达斯一世。它的基因中伊述 DNA 的比例远超常人，这也让它与伊述遗物的相性非常契合。说简单点就是能更好地使用并掌握伊甸碎片及伊述科技，这一特征也将会遗传到他的子孙身上，而他手中的利奥尼达斯之矛，正是伊述文明所遗留下的一点碎片，战斗中他甚至可以预测对手的动作。</p><p>在温泉关战役中，面对来势汹汹的波斯大军，他率领著名的斯巴达三百勇士死守在温泉关，誓死抵抗波斯帝国的入侵。血战足足持续了三天，直到最终三百勇士全部战死。但温泉关战役却成功拖延了波斯大军的进攻速度，为雅典和其他城邦争取了宝贵的备战时间，也为希腊最终取得胜利立下了大功。</p><p>公元前 465 年，大流士，原名阿尔达班，本是波斯的一名禁卫。但面对薛西斯一世的残暴统治，他认清了现实以及幕后的真正黑手。于是以他为核心的一个秘密组织正式成立，以消灭上古维序者及其”盟友“为己任。而波斯王薛西斯一世自然是首选目标，这也是袖箭在历史上第一次登场。但大流士的刺杀举动彻底激怒了上古维序者，对他的追杀也接踵而至。</p><p>公元前 458 年，英勇战死的斯巴达国王利奥尼达斯的外孙女卡珊德拉出生了。身为斯巴达王室后裔的她，从小就被寄予厚望，人们都希望她能成长为一个像她外公那样健壮而勇猛的战士。然而一条“虚假”的神谕却改变了他的人生。神谕将她的弟弟阿里克西欧斯视为不祥之人，会给斯巴达带来毁灭。当行刑者将她的弟弟丢进悬崖之时，卡珊德拉挣脱了束缚，向行刑者猛扑了过去。她本想救下弟弟，但不幸的是弟弟与行刑者同时掉入了悬崖。行刑者的死让卡珊德拉也成为了众矢之的，“杀人者”的咒骂声不断在她的耳边响起。出于对斯巴达法律的敬重，她的父亲尼科拉欧斯将军只能将年幼的卡珊德拉丢下了悬崖。</p><p>而卡珊德拉并没有死，在骨骸堆中醒来的她，发现身边正躺着一把断矛，那正是她外公列奥尼达斯一世曾在温泉关使用过的传家之宝。随后，卡珊德拉带着断矛离开了斯巴达的土地，一路漂泊后，终于来到了一个叫凯法隆尼亚的岛屿。现实中荷马史诗《奥德赛》的主角，奥德修斯便降生于此，这也正是《刺客信条：奥德赛》名字的由来。</p><p>凭借着儿时所学的战斗技能以及外公列奥尼达斯的基因，成年后的卡珊德拉很快成为了一名小有名气的雇佣兵，绰号”训鹰人“。公元前 431 年，卡珊德拉被卷进了伯罗奔尼撒战争，参战的双方分别是以雅典为首的提洛同盟和以斯巴达为首的伯罗奔尼撒联盟。这场战争一打就是十年，最终雅典军事统帅克勒翁被卡珊德拉扭断了脖子，战争至此也告一段落。而在战争期间，卡珊德拉也终于见到了久违的母亲，并从母亲那里了解到了自己的身世之谜。但卡珊德拉的强大血脉也引起了上古维序者的高度重视，于是他们派出一个分支，猎人维序者前来追杀卡珊德拉。公元前 429 年，还记得刺杀了波斯王薛西斯一世的大流士，一晃 36 年过去了，他为了躲避上古维序者的追杀，带着儿子奈塔卡斯早已来到了希腊，就这样，同被上古维序者追杀的大流士和卡珊德拉不期而遇了。在之后的时间里，他们多次携手击退了上古维序者，并在共同相处的这段日子里，卡珊德拉也与大流士的儿子奈塔卡斯日久生情，两人最终结合并诞下了一个男孩，名为艾匹底欧斯。但卡珊德拉随即意识到颠沛流离的生活并不利于孩子的成长，于是她拜托大流士将儿子带往埃及，从此隐姓埋名。大流士答应了卡珊德拉的请求，带着孙子踏上了前往埃及的旅程。没有了牵挂后，此时的卡珊德拉终于要去揭开自己的身世之谜了，去寻找她的亲生父亲。公元前 422 年，锡拉岛某个远古神殿的所在地，传说中的伊述城市——亚特兰蒂斯就坐落在神殿的尽头。在这里，卡珊德拉终于找到了自己的亲生父亲毕达哥拉斯。现实中，他可是大名鼎鼎的数学之父，她的父亲凭借伊甸碎片赫尔墨斯之杖已经活到了 148 岁，并一直在亚特兰蒂斯潜心研究伊述文明所留下的知识。但在研究过程中，他发现无论是伊甸碎片还是伊甸科技，都对人类充满了致命诱惑，一旦落入”邪恶之人“手中，后果将不堪设想。于是，在卡珊德拉的帮助下，他们一起封印了亚特兰蒂斯。</p><p>毕达哥拉斯最后将权杖传给了女儿，当权杖脱手的那一刻，也意味着他的生命即将完结。卡珊德拉接过的这柄权杖是由伊述哲学家赫尔墨斯制造。除了永生的能力外，这柄权杖还隐藏着一个惊天阴谋。卡珊德拉的前半生经历了家人的生死离别、王国的兴衰起伏，她曾与希罗多德、苏格拉底等古代先贤谈笑风生，把酒言欢，并由于多次挫败了上古维序者的阴谋，也被刺客组织尊为刺客先驱之一。而凭借赫尔墨斯权杖的力量获得永生后，卡珊德拉在接下来的两千多年里，则肩负起了平衡世间万物的职责，这其中也包括刺客与圣殿骑士的平衡。在这漫长的岁月中，训鹰人卡珊德拉一直在默默地注视着你。 而卡珊德拉的儿子艾匹底欧斯在被爷爷大流士带到埃及后，也在那里落地生根，直到四年后，他的后人艾雅的出现，她将开启一场持续千年的”秘密战争“。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>胶囊神经网络</title>
      <link href="/2023/04/24/%E8%83%B6%E5%9B%8A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/04/24/%E8%83%B6%E5%9B%8A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p> 胶囊是一组神经元，其活动向量表示特定类型实体（如对象或对象部分）的实例化参数。<strong>我们使用活动向量的长度来表示实体存在的概率，使用方向来表示实例化参数</strong>。在一个层级上，活跃的胶囊通过变换矩阵为更高层级胶囊的实例化参数进行预测。当多个预测一致时，更高层级的胶囊变为活跃状态。我们展示了一个经过区分性训练的多层胶囊系统在MNIST数据集上实现了最先进的性能，并且在识别高度重叠的数字方面比卷积网络表现得更好。为了实现这些结果，我们使用了迭代的基于协议的路由机制：较低层级的胶囊更倾向于将其输出发送到其活动向量与来自较低层级胶囊的预测具有大标量积的更高层级胶囊。</p><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><p>人类的视觉系统通过使用经过精心确定的注视点序列来忽略不相关的细节，以确保只有光学阵列的极小部分会以最高分辨率被处理。我们很难从内省中理解我们对场景的知识来自于注视点序列的哪些部分，以及我们从单个注视中获取了多少信息，但在本文中我们将假设单个注视不仅可以给我们一个单独的识别对象和其属性的信息。我们假设我们的多层视觉系统在每个注视上创建了一个类似于语法树的结构，并忽略了如何协调这些单注视语法树的问题。</p><p>语法树通常是通过动态分配内存进行构建的。然而，根据Hinton等人的说法，对于单个注视，我们将假设语法树就像雕塑从岩石中刻出来一样，<strong>从一个固定的多层神经网络中刻出来</strong>。每个层将被分成许多称为“胶囊”的小组神经元，并且语法树中的每个节点将对应一个活动的胶囊。使用迭代路由过程，每个活动的胶囊将选择上一层中的一个胶囊作为其在树中的父节点。对于视觉系统的较高层，这个迭代过程将解决将部分分配给整体的问题。</p><p>活动胶囊内神经元的活动表示出图像中特定实体的各种属性。这些属性可以包括许多不同类型的实例化参数，例如姿态（位置，大小，方向），变形，速度，反射率，色调，纹理等等。一个非常特殊的属性是实体在图像中的存在性。表示存在性的一种明显方式是使用单独的逻辑单元，其输出是实体存在的概率。在本文中，我们探讨了一种有趣的替代方案，<strong>即使用实例化参数向量的整体长度来表示实体的存在，并强制向量的方向表示实体的属性</strong>。我们通过应用非线性操作来确保胶囊的向量输出长度不能超过1，但保持向量方向不变并缩小其大小。</p><p>这段内容主要讲了胶囊网络的动态路由机制以及与卷积神经网络（CNN）的区别。胶囊网络中的胶囊输出是一个向量，可以使用动态路由机制将其发送到合适的上层节点。<strong>这种机制会计算胶囊输出和每个可能的上层节点的“预测向量”的内积，并根据内积的大小来动态调整节点间的连接系数</strong>。这种“路由-by-agreement”比CNN中的max-pooling更加高效，能够更好地实现对高度重叠物体的分割。</p><p>另外，为了能够在不同位置重用训练好的权重值，胶囊网络的大多数层采用卷积结构，与CNN类似。在低层胶囊中，位置信息是通过激活的胶囊来编码的。随着层次的升高，位置信息越来越多地被编码在胶囊输出向量的实数分量中。因此，胶囊网络的维度应该随着层次的升高而增加，以更好地表示越来越复杂的实体。</p><h1 id="2-胶囊的矢量输入和输出是如何计算的"><a href="#2-胶囊的矢量输入和输出是如何计算的" class="headerlink" title="2 胶囊的矢量输入和输出是如何计算的"></a>2 胶囊的矢量输入和输出是如何计算的</h1><p>这篇文章探讨了关于胶囊的实现方法。虽然有很多方法可以实现胶囊，但是本文的目的并不是探究所有方法，而只是展示一个相当直观的实现方法，同时说明动态路由的帮助作用。</p><p>我们希望<strong>胶囊的输出向量长度能够表示该胶囊代表的实体在当前输入中出现的概率</strong>。因此，我们使用一个非线性的“压缩”函数来确保短向量被压缩到几乎为零的长度，而长向量则被压缩到略小于1的长度。我们相信，后续的学习过程会很好地利用这个非线性。<br>$$<br>v_j&#x3D;\frac{|s_j|^2}{1+|s_j|^2}\frac{s_j}{|s_j|}<br>$$<br> 其中$v_j$是第j个胶囊的向量输出，$s_j $是该胶囊的总输入</p><p>对于除第一层胶囊以外的所有胶囊，胶囊的总输入$s_j $是来自下一层所有“预测向量”$u_{j|i} $的加权和，由将下一层胶囊的输出$u_i $乘以权重矩阵$W_{ij} $产生。<br>$$<br>s_j&#x3D;\sum_{i}c_{ij}u_{j|i}<br>$$<br>其中，$c_{ij} $是通过迭代的动态路由过程确定的耦合系数。</p><p>胶囊$i $和上层的所有胶囊之间的耦合系数之和为1，并由“路由softmax”确定。其初始logits$b_{ij} $是胶囊$i $应该与胶囊$j $耦合的先验概率的对数。<br>$$<br>c_{ij}&#x3D;{exp(b_{ij})\over \sum_{k}exp(b_{ik})}<br>$$<br>log priors可以与所有其他权重一起进行有区别的学习。它们取决于两个胶囊的位置和类型，但不取决于当前的输入图像。然后，通过测量每个胶囊$j $的当前输出$v_j $与胶囊$i$进行的预测${u}_{j|i}$之间的一致性来迭代地改进初始耦合系数。</p><p>一致性是标量积$a_{ij}&#x3D;v_j\cdot u_{j|i} $。将该一致性视为对数似然，并将其添加到$b_{ij} $的初始logit之前，在计算连接胶囊$i $和更高级别胶囊的所有耦合系数的新值之前进行处理。</p><p>在卷积胶囊层中，每个胶囊针对上层的每种类型的胶囊输出一个本地网格的向量，针对每个网格成员以及每种类型的胶囊使用不同的转换矩阵。</p><p>这段伪代码描述了CapsNet的路由算法。路由算法的目的是将下一层的胶囊与当前层的胶囊相互关联起来，以便在训练过程中学习到空间层次结构。以下是该算法的步骤：</p><ol><li>初始化所有$b_{ij} $的值为0。</li><li>对于当前层的每个胶囊$i $和下一层的每个胶囊$j $，都将其对应的$b_{ij} $值初始化为0。</li><li>迭代$r $次：</li><li>对于当前层的每个胶囊$i $，计算其输出$c_i $。输出$c_i $是通过将$b_{ij} $值传递到softmax函数中计算得到的。</li><li>对于下一层的每个胶囊$j $，计算其输入$s_j $。输入$s_j $是由当前层的所有胶囊$i $的输出$c_i $加权求和得到的。</li><li>对于下一层的每个胶囊$j $，将其输入$s_j $传递到压缩函数中，得到压缩后的输出$v_j $。</li><li>对于当前层的每个胶囊$i $和下一层的每个胶囊$j $，计算$b_{ij} $的值。$b_{ij} $的值是当前层的胶囊$i $的输出$u_i $与下一层的胶囊$j $的压缩后的输出$v_j $之间的点积。</li><li>将下一层的每个胶囊$j $的输出$v_j $返回。</li></ol><p>简单来说，<strong>路由算法通过计算当前层胶囊的输出和下一层胶囊的输入之间的关系来确定它们之间的联系，并将下一层胶囊的输入压缩成长度为1的向量</strong>。这个压缩函数通过使用非线性函数来确保输出向量的长度始终为1。在训练过程中，路由算法不断更新每个$b_{ij} $的值，以便使每个胶囊的输出与其相应的输入高度相关。最终，路由算法通过迭代更新来学习每个胶囊之间的联系和层次结构。</p><h1 id="3-Margin-loss"><a href="#3-Margin-loss" class="headerlink" title="3 Margin loss"></a><strong>3 Margin loss</strong></h1><p>我们使用实例向量的长度来表示一个胶囊所代表的实体存在的概率。如果图像中存在数字类别k，我们希望数字类别k的顶层胶囊有一个长的实例向量。为了允许多个数字存在，我们为每个数字胶囊k使用单独的边界损失$L_k $。<br>$$<br>L_k&#x3D;T_kmax(0,m^+-|v_k|)^2+\lambda(1-T_k)max(0,|v_k|-m^-)^2<br>$$<br>当数字类别k存在时，$T_k&#x3D;1 $，否则$T_k&#x3D;0 $。为了防止学习过程中将所有数字胶囊的活动向量长度缩小，我们使用了一个缩小因子λ。每个数字胶囊的边界损失$L_k $由两个部分组成，分别是当$T_k&#x3D;1 $时对应于实例向量的长度$v_k $和$m^+ $的差值，和当$T_k&#x3D;0 $时对应于实例向量的长度$v_k $和$m^- $的差值。我们将正边界$m^+ $设置为0.9，将负边界$m^- $设置为0.1，将缩小因子λ设置为0.5。总损失是所有数字胶囊的损失之和。</p><h1 id="4-CapsNet-architecture"><a href="#4-CapsNet-architecture" class="headerlink" title="4 CapsNet architecture"></a>4 <strong>CapsNet architecture</strong></h1><p><img src="/.io//Blog\source_posts\胶囊神经网络\Snipaste_2023-04-24_09-49-00.png" alt="Snipaste_2023-04-24_09-49-00"></p><p>图1：一个简单的三层CapsNet。该模型给出了与深度卷积相当的结果网络。每个胶囊的活性载体的长度在DigitCaps中，层指示每个类的实例的存在，并用于计算分类损失。$W_{ij} $是每个$u_i $之间的权重矩阵，i∈（1，32×6×6）在初级胶囊中并且$v_j $，j∈（1, 10）</p><p><a href="https://sxqm8q3k1q2.feishu.cn/docx/BKbidFQygozCioxVoIxclaDpnnb#HGgCdyOoGoKcuYxETfgcjwOunrc">图1</a>展示了一个简单的CapsNet架构。该架构较为浅，只有两个卷积层和一个全连接层。Conv1具有256个9×9卷积核，步长为1，并使用ReLU激活函数。这一层将像素强度转换为局部特征探测器的活动，并将其作为主要胶囊的输入。 主要胶囊是多维实体的最低级别，从逆图形学的角度来看，激活主要胶囊对应于反演渲染过程。这是一种非常不同的计算方式，与拼合实例化部分以形成熟悉的整体是胶囊擅长的内容非常不同。 第二层（PrimaryCapsules）是一个卷积胶囊层，具有32个卷积8D胶囊通道（即每个主要胶囊包含8个带有9×9内核和步幅为2的卷积单元）。每个主要胶囊输出看到与胶囊中心位置的重叠的所有256×81个Conv1单元的输出。总共，PrimaryCapsules有[32×6×6]个胶囊输出（每个输出是一个8D向量），并且[6×6]网格中的每个胶囊都共享它们的权重。可以将PrimaryCapsules视为具有<a href="https://sxqm8q3k1q2.feishu.cn/docx/BKbidFQygozCioxVoIxclaDpnnb#XOoGdwUuIoec4YxeQiec1ifrn4g">公式1</a>作为块非线性的卷积层。最后一层（DigitCaps）每个数字类别有一个16D胶囊，每个胶囊都从下面层的所有胶囊接收输入。 我们<strong>只在两个相邻的胶囊层之间进行路由</strong>（例如PrimaryCapsules和DigitCaps）。由于Conv1输出是1D，因此在其空间中没有方向需要协商。因此，在Conv1和PrimaryCapsules之间不使用路由。所有路由logits（$b_{ij} $）都初始化为零。因此，最初将胶囊输出（$u_i $）发送到所有父胶囊（v0…v9），概率相等（$c_{ij} $）。 我们的实现是在TensorFlow中完成的，并使用Adam优化器及其TensorFlow默认参数，包括指数衰减的学习率，以最小化<a href="https://sxqm8q3k1q2.feishu.cn/docx/BKbidFQygozCioxVoIxclaDpnnb#VIisd2m8OoqacUxeo0HciuVCnBg">公式4</a>中边际损失的总和。</p><h2 id="4-1-重构作为一种正则化方法"><a href="#4-1-重构作为一种正则化方法" class="headerlink" title="4.1 重构作为一种正则化方法"></a>4.1 重构作为一种正则化方法</h2><p><img src="/.io//Blog\source_posts\胶囊神经网络\Snipaste_2023-04-24_10-20-22.png" alt="Snipaste_2023-04-24_10-20-22"></p><p>图2: 从DigitCaps层表示中重建数字的解码器结构。在训练过程中，通过最小化图像和Sigmoid层输出之间的欧几里得距离来重建数字。我们在训练过程中使用真实标签作为重建目标。</p><p><img src="/.io//Blog\source_posts\胶囊神经网络\Snipaste_2023-04-24_10-23-28.png" alt="Snipaste_2023-04-24_10-23-28"></p><p>图3：使用3个路由迭代的CapsNet的MNIST测试重建示例。 （l，p，r）分别表示标签，预测和重建目标。最右侧的两列显示了一个失败示例的两个重建图像，并解释了模型如何在该图像中混淆5和3。其他列是正确分类的结果，并显示模型保留了许多细节同时平滑了噪声。</p><p>我们使用额外的重构损失来促使数字胶囊对输入数字的实例化参数进行编码。在训练过程中，我们屏蔽除正确数字胶囊的活动向量之外的所有胶囊。然后，我们使用该活动向量来重构输入图像。数字胶囊的输出被馈送到一个解码器中，该解码器由3个完全连接的层组成，用于模拟像素强度，如<a href="https://sxqm8q3k1q2.feishu.cn/docx/BKbidFQygozCioxVoIxclaDpnnb#DqcMd8IasougSOx4NRTcqbOMnqg">图2</a>所示。我们最小化逻辑单元的输出与像素强度之间的平方差之和。我们通过将重构损失缩小0.0005的比例来使其在训练期间不会主导边缘损失。如<a href="https://sxqm8q3k1q2.feishu.cn/docx/BKbidFQygozCioxVoIxclaDpnnb#JSeGdqEGAoUWIsxigvOcEIKinFg">图3</a>所示，CapsNet的16D输出的重构具有鲁棒性，同时仅保留重要细节。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/2023/04/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/04/10/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h1><h2 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h2><ul><li><p>变量定义的一般形式就是：</p><ul><li>&lt;类型名称&gt; &lt;变量名称&gt;;</li></ul></li><li><p>变量需要一个名字，变量的名字是一种“标识符”，意思是它是用来识别这个和那个的不同的名字。</p></li><li><p>标识符有标识符的构造规则。基本的原则是：标识符只能由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线</strong>组成，数字不可以出现在第一个位置上，C语言的关键字（有的地方叫它们保留字）不可以用做标识符。</p></li><li><p>所有变量在第一次被使用（出现在赋值运算符的右边）之前应该被赋值一次。</p></li><li><p>C是一种有类型的语言，所有的变量在使用之前必须<strong>定义</strong>或<strong>声明</strong>，所有的变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。</p></li></ul><h2 id="1-2-常量"><a href="#1-2-常量" class="headerlink" title="1.2 常量"></a>1.2 常量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> AMOUNT = <span class="number">100</span></span><br><span class="line">    <span class="type">int</span> price = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;price);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> change = AMOUNT - price;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找您%d元\n&quot;</span>, change);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>固定不变的数，是常数。直接写在程序里，我们称作直接量（literal）</p></li><li><p>更好的方式，是定义一个常量：</p><ul><li><code>const int AMOUNT = 100</code>;</li></ul></li><li><p><code>const</code>是一个修饰符，加在int的前面，用来给这个变量加上一个const（不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了。</p></li><li><p>如果你试图对常量做修改，把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误。</p></li></ul><h2 id="1-3-浮点数"><a href="#1-3-浮点数" class="headerlink" title="1.3 浮点数"></a>1.3 浮点数</h2><ul><li>带小数点的数值。浮点这个词的本意就是指小数点是浮动的，是计算机内部表达非整数（包含分数和无理数）的一种方式。</li><li>当浮点数和整数放到一起运算时，C会将整数转换成<strong>浮点数</strong>，然后进行浮点数的运算。</li></ul><h2 id="1-4-运算符"><a href="#1-4-运算符" class="headerlink" title="1.4 运算符"></a>1.4 运算符</h2><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">运算</th><th align="center">结合关系</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">+</td><td align="center">单目不变</td><td align="center">自右向左</td><td align="center">a*+b</td></tr><tr><td align="center">1</td><td align="center">-</td><td align="center">单目取负</td><td align="center">自右向左</td><td align="center">a*-b</td></tr><tr><td align="center">2</td><td align="center">*</td><td align="center">乘</td><td align="center">自左向右</td><td align="center">a*b</td></tr><tr><td align="center">2</td><td align="center">&#x2F;</td><td align="center">除</td><td align="center">自左向右</td><td align="center">a&#x2F;b</td></tr><tr><td align="center">2</td><td align="center">%</td><td align="center">取余</td><td align="center">自左向右</td><td align="center">a%b</td></tr><tr><td align="center">3</td><td align="center">+</td><td align="center">加</td><td align="center">自左向右</td><td align="center">a+b</td></tr><tr><td align="center">3</td><td align="center">-</td><td align="center">减</td><td align="center">自左向右</td><td align="center">a-b</td></tr><tr><td align="center">4</td><td align="center">&#x3D;</td><td align="center">赋值</td><td align="center">自右向左</td><td align="center">a&#x3D;b</td></tr></tbody></table><h2 id="1-5-关系运算"><a href="#1-5-关系运算" class="headerlink" title="1.5 关系运算"></a>1.5 关系运算</h2><ul><li>所有的关系运算符的优先级比算术运算的低，但是比赋值运算的高。</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">&#x3D;&#x3D;</td><td align="center">相等</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不相等</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于或等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于或等于</td></tr></tbody></table><h1 id="2-判断"><a href="#2-判断" class="headerlink" title="2 判断"></a>2 判断</h1><h2 id="2-1-多路分支switch-case"><a href="#2-1-多路分支switch-case" class="headerlink" title="2.1 多路分支switch-case"></a>2.1 多路分支switch-case</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (控制表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 常量:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">case</span> 常量:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    语句    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制表达式只能是<strong>整数</strong>类型的结果</li><li>常量可以是常数，也可以是常数计算的表达式</li></ul><h2 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h2><ul><li><p>循环体内要有改变条件的机会</p></li><li><p>for(初始动作；条件；每轮的动作) { }</p><ul><li>for中的每一个表达式都是可以省略的</li><li>for(；条件；) &#x3D;&#x3D; while(条件)</li></ul></li><li><p>如果有固定次数，用for</p></li><li><p>如果必须执行一次，用do_while</p></li><li><p>其他情况用while</p></li></ul><h1 id="3-数据"><a href="#3-数据" class="headerlink" title="3 数据"></a>3 数据</h1><h2 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h2><ul><li>所表达的数的范围：char &lt; short &lt; int &lt; float &lt; double</li></ul><h3 id="3-1-1-sizeof"><a href="#3-1-1-sizeof" class="headerlink" title="3.1.1 sizeof"></a>3.1.1 sizeof</h3><ul><li><p>sizeof是一个运算符，给出某个类型或变量在内存中所占的字节数</p><ul><li><code>sizeof(int)</code></li><li><code>sizeof(i)</code></li></ul></li><li><p>是<strong>静态运算符</strong>，它的结果在编译时刻就决定了</p></li><li><p>不要在sizeof的括号里做运算，这些运算不会做的</p></li></ul><h3 id="3-1-2-整数"><a href="#3-1-2-整数" class="headerlink" title="3.1.2 整数"></a>3.1.2 整数</h3><ul><li><p>char：1字节（8比特）-128 ~ 127</p></li><li><p>short：2字节 -32768 ~ 32767</p></li><li><p>int：取决于编译器（CPU）,通常的意义是“1个字”</p></li><li><p>long：取决于编译器（CPU）,通常的意义是“1个字”</p></li><li><p>long long：8字节</p></li><li><p>为什么整数要有那么多种？</p><ul><li>为了准确表达内存，做底层程序的需要</li></ul></li><li><p>没有特殊需要，就选择int</p><ul><li>现在CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢</li><li>*现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)</li></ul></li><li><p>unsigned与否只是输出的不同，内部计算是一样的</p></li></ul><h3 id="3-1-3-unsigned"><a href="#3-1-3-unsigned" class="headerlink" title="3.1.3 unsigned"></a>3.1.3 unsigned</h3><ul><li><p>如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U</p><ul><li><code>255U</code></li></ul></li><li><p>用l或L表示long(long)</p></li><li><p>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</p></li></ul><h3 id="3-1-4-浮点数"><a href="#3-1-4-浮点数" class="headerlink" title="3.1.4 浮点数"></a>3.1.4 浮点数</h3><ul><li>printf输出inf表示<strong>超过范围</strong>的浮点数：±∞</li><li>printf输出nan表示<strong>不存在</strong>的浮点数</li></ul><p>运算精度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b, c;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">1.345f</span>;</span><br><span class="line">    b = <span class="number">1.123f</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">2.468</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;相等\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不相等! c=%.10f,或%f\n&quot;</span>,c, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带小数点的字面量是double而非float</li><li>float需要用f或F后缀来表明身份</li><li><code>f1 == f2</code>可能失败<ul><li><code>fabs(f1-f2) &lt; 1e-12</code></li></ul></li></ul><p>浮点类型选择</p><ul><li>如果没有特殊需要，只是用double</li><li>现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</li></ul><h3 id="3-1-5-bool"><a href="#3-1-5-bool" class="headerlink" title="3.1.5 bool"></a>3.1.5 bool</h3><ul><li><code>#include &lt;stdbool.h&gt;</code></li><li>之后就可以使用bool和true、false</li></ul><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h2><ul><li><p>当运算符的两边出现不一致的类型时，会自动转换成较大的类型</p><ul><li>大的意思是能表达的数的范围更大</li><li>char—&gt;short—&gt;int—&gt;long—&gt;long long</li><li>int—&gt;float—&gt;double</li></ul></li><li><p>对于printf，任何小于int的类型会被转换成int；float会被转换成double</p></li><li><p>但是scanf不会，要输入short，需要%hd</p></li><li><p>要把一个量强制转换成另一个类型（通常是较小的类型），需要：（类型）值</p></li><li><p>注意这时候的安全性，小的变量不总能表达大的量</p><ul><li><code>(short)32768</code></li></ul></li><li><p>只是从那个变量计算出了一个<strong>新的类型的值</strong>，它并不改变那个变量，无论是值还是类型都不改变</p></li></ul><h2 id="3-3-逻辑运算"><a href="#3-3-逻辑运算" class="headerlink" title="3.3 逻辑运算"></a>3.3 逻辑运算</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">!</td><td align="center">逻辑非</td><td align="center">!a</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td><td align="center">a&amp;&amp;b</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td><td align="center">a||b</td></tr></tbody></table><h3 id="3-3-1-优先级"><a href="#3-3-1-优先级" class="headerlink" title="3.3.1 优先级"></a>3.3.1 优先级</h3><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">()</td><td align="center">从左到右</td></tr><tr><td align="center">2</td><td align="center">! + - ++ –</td><td align="center">从右到左</td></tr><tr><td align="center">3</td><td align="center">* &#x2F; %</td><td align="center">从左到右</td></tr><tr><td align="center">4</td><td align="center">+ -</td><td align="center">从左到右</td></tr><tr><td align="center">5</td><td align="center">&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td align="center">从左到右</td></tr><tr><td align="center">6</td><td align="center">&#x3D;&#x3D; !&#x3D;</td><td align="center">从左到右</td></tr><tr><td align="center">7</td><td align="center">&amp;&amp;</td><td align="center">从左到右</td></tr><tr><td align="center">8</td><td align="center">||</td><td align="center">从左到右</td></tr><tr><td align="center">9</td><td align="center">&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;</td><td align="center">从右到左</td></tr></tbody></table><h3 id="3-3-2-短路"><a href="#3-3-2-短路" class="headerlink" title="3.3.2 短路"></a>3.3.2 短路</h3><ul><li><p>逻辑运算是自左向右进行的，<strong>如果左边的结果已经能够决定结果了，就不会做右边的计算</strong></p><ul><li><code>a==6 &amp;&amp; b==1</code></li><li><code>a==6 &amp;&amp; b+=1</code></li></ul></li><li><p>对于&amp;&amp;，左边是false时就不做右边了</p></li><li><p>对于||，左边是true时就不做右边了</p></li><li><p><strong>不要把赋值，包括复合赋值组合进表达式</strong></p></li></ul><h2 id="3-4-条件运算符"><a href="#3-4-条件运算符" class="headerlink" title="3.4 条件运算符"></a>3.4 条件运算符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = (count &gt; <span class="number">20</span>)?count<span class="number">-10</span>:count+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(count&gt;<span class="number">20</span>)</span><br><span class="line">    count = count - <span class="number">10</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    count = count + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>条件运算符额优先级高于赋值运算符，但是低于其他运算符</li></ul><h3 id="3-4-1-逗号运算符"><a href="#3-4-1-逗号运算符" class="headerlink" title="3.4.1 逗号运算符"></a>3.4.1 逗号运算符</h3><ul><li>逗号用来连接两个表达式，并以其<strong>右边</strong>的表达式的值作为它的<strong>结果</strong>。逗号的优先级是所有的运算符中<strong>最低</strong>的，所以它两边的表达式会先计算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">3</span>+<span class="number">4</span>,<span class="number">5</span>+<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for中使用</p><ul><li><code>for(i=0 , j=10 ; i&lt;j ; i++ , j-- )</code></li></ul><h1 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=begin; i&lt;=end; i++)&#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d到%d的和是%d\n&quot;</span>, begin, end, sum);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    sum(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    sum(<span class="number">35</span>, <span class="number">45</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样把sum()写在上面，是因为：C的编译器<strong>自上而下</strong>顺序分析你的代码</p><ul><li>在看到<code>sum(1, 10)</code>的时候，它需要知道sum()的样子，也就是sum()要几个参数，每个参数的类型如何，返回什么类型，这样它才能检查你对sum()的调用是否正确。</li></ul><h2 id="4-1-参数传递"><a href="#4-1-参数传递" class="headerlink" title="4.1 参数传递"></a>4.1 参数传递</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cheer</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cheer %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    cheer(<span class="number">2.4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞</li><li>编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t=a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    swap(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C语言在调用函数时，永远只能传值给函数</li><li>每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</li></ul><h2 id="4-2-本地-局部-变量"><a href="#4-2-本地-局部-变量" class="headerlink" title="4.2 本地(局部)变量"></a>4.2 本地(局部)变量</h2><ul><li><p>函数的每次运行，就产生了一个独立的变量空间，在这个空间中变量，是函数的这次运行所独有的，称作本地变量</p></li><li><p>定义在函数内部变量就是本地变量，<strong>参数</strong>也是本地变量</p></li><li><p>本地变量是定义在块内的</p><ul><li>它可以是定义在<strong>函数的块内</strong></li><li>也可以定义在<strong>语句的块内</strong></li><li>甚至可以随便拉一对大括号来定义变量</li></ul></li><li><p>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了</p></li><li><p>块外面定义的变量在里面仍然有效</p></li><li><p>块里面定义了和外面同名的变量则<strong>掩盖了外面</strong>的</p></li><li><p>不能在一个块内定义同名的变量</p></li><li><p>本地变量<strong>不会被默认初始化</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">6</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-数组"><a href="#5-数组" class="headerlink" title="5 数组"></a>5 数组</h1><ul><li>其中所有的元素具有相同的数据类型</li><li>一旦创建，不能改变大小</li><li>*数组中的元素在内存中是<strong>连续依次</strong>排列的</li></ul><h2 id="5-1-下标范围"><a href="#5-1-下标范围" class="headerlink" title="5.1 下标范围"></a>5.1 下标范围</h2><ul><li>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写</li><li>一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃<ul><li><strong>segmentation fault</strong></li></ul></li></ul><h2 id="5-2-集成初始化定位"><a href="#5-2-集成初始化定位" class="headerlink" title="5.2 集成初始化定位"></a>5.2 集成初始化定位</h2><p><strong>C99 ONLY！</strong></p><p><code>int a[10] = &#123;[0]=2, [2]=3, 6&#125;;</code></p><ul><li>用[n]在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面</li><li>其他位置的值补零</li><li>也可以不给出数组大小，让编译器算</li><li>特别适合初始数据稀疏的数组</li></ul><h2 id="5-3-数组的大小"><a href="#5-3-数组的大小" class="headerlink" title="5.3 数组的大小"></a>5.3 数组的大小</h2><ul><li>sizeof给出整个数组所占据的内容的大小，单位是字节<ul><li><code>sizeof(a)/sizeof(a[0])</code></li></ul></li><li>sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组二点单元个数</li><li>这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码</li></ul><h2 id="5-4-数组的赋值"><a href="#5-4-数组的赋值" class="headerlink" title="5.4 数组的赋值"></a>5.4 数组的赋值</h2><p><code>int a[] = &#123;2, 4, 6, 8, 10&#125;;</code></p><p><code>int b[] = a;</code></p><ul><li>数组变量本身不能被赋值</li><li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通常都是使用for循环，让循环变量i从0到&lt;数组的长度，这样循环体内最大的i正好是数组最大的有效下标</li><li><strong>常见错误</strong>是：<ul><li>循环结束条件是&lt;&#x3D;数组长度，或：</li><li>离开循环后，继续用i的值来做数组元素的下标！</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[], <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == key)&#123;</span><br><span class="line">            ret = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span> ,<span class="number">11</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    loc = search(x, a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span>(loc!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d在第%d个位置上\n&quot;</span>, x, loc);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不存在\n&quot;</span>, x);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小</strong><ul><li>数组作为函数的参数时<ul><li>不能在[]中给出数组的大小</li><li>不能再利用sizeof来计算数组的元素个数！</li></ul></li></ul></li></ul><h2 id="5-5-数组应用：素数"><a href="#5-5-数组应用：素数" class="headerlink" title="5.5 数组应用：素数"></a>5.5 数组应用：素数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> knownPrimes[], <span class="type">int</span> number0fKnownPrimes)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> prime[number] = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count &lt; number)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(i, prime, count))&#123;</span><br><span class="line">            prime[count++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 调试代码</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i=%d \tcnt=%d\t&quot;</span>, i, count);</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;number; i++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,prime[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;number; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, prime[i]);</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprime</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> knownPrimes[], <span class="type">int</span> number0fKnownPrimes)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;number0fKnownPrimes; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % knownPrimes[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造素数表</p><ol><li>令x为2</li><li>将2x、3x、4x（偶数）直至ax&lt;n的数标记为非素数</li><li>令x为下一个没有被标记为非素数的数，重复2；直到所有的数都已经尝试完毕</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">伪代码：构造n以内（不含）的素数表</span><br><span class="line"><span class="number">1.</span>开辟prime[n]，初始化其所有元素为<span class="number">1</span>，prime[x]为<span class="number">1</span>表示x是素数</span><br><span class="line"><span class="number">2.</span>令x=<span class="number">2</span></span><br><span class="line"><span class="number">3.</span>如果x是素数，则对于(i=<span class="number">2</span>;x*i&lt;n;i++)令prime[i*x]=<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>令x++，如果x&lt;n，重复<span class="number">3</span>，否则结束</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> maxNumber = <span class="number">25</span>;</span><br><span class="line">    <span class="type">int</span> isPrime[maxNumber];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;maxNumber; i++)&#123;</span><br><span class="line">        isPrime[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">2</span>; x&lt;maxNumber; x++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[x])&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">2</span>; i*x&lt;maxNumber; i++)&#123;</span><br><span class="line">                isPrime[i*x] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;maxNumber; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-6-二维数组"><a href="#5-6-二维数组" class="headerlink" title="5.6 二维数组"></a>5.6 二维数组</h2><h3 id="5-6-1-初始化"><a href="#5-6-1-初始化" class="headerlink" title="5.6.1 初始化"></a>5.6.1 初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>列数是必须给出的，行数可以由编译器来数</li><li>每行一个{}，逗号分隔</li><li>如果省略，表示补零</li><li>也可以用定位（<strong>C99 ONLY</strong>）</li></ul><h3 id="5-6-2-tic-tac-toe游戏"><a href="#5-6-2-tic-tac-toe游戏" class="headerlink" title="5.6.2 tic-tac-toe游戏"></a>5.6.2 tic-tac-toe游戏</h3><ol><li>读取一个3×3的矩阵，矩阵中的数字为1表示该位置上有一个X，为0表示为O</li><li>程序判断这个矩阵中是否有获胜的一方，输出表示获胜一方的字符X或O，或输出无人获胜</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> board[size][size];</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> numOfX;</span><br><span class="line">    <span class="type">int</span> numOfO;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-1</span>;    <span class="comment">//-1:没人赢，1:X赢，0:O赢</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;board[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查行 能否用一个两重循环来检查行和列？？</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size &amp;&amp; result == <span class="number">-1</span>; i++)&#123;</span><br><span class="line">        numOfO = numOfX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                numOfX++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                numOfO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numOfO == size)&#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numOfX == size)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查列</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;size &amp;&amp; result == <span class="number">-1</span>; j++)&#123;</span><br><span class="line">            numOfO = numOfX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    numOfX++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    numOfO++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">if</span>(numOfO == size)&#123;</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numOfX == size)&#123;</span><br><span class="line">                result = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查对角线</span></span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>)&#123;</span><br><span class="line">        numOfO = numOfX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][i] == <span class="number">1</span>)&#123;</span><br><span class="line">                numOfX++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                numOfO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numOfO == size)&#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numOfX == size)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>)&#123;    </span><br><span class="line">        numOfO = numOfX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][size-i<span class="number">-1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                numOfX++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                numOfO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numOfO == size)&#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numOfX == size)&#123;</span><br><span class="line">            result = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="6-指针"><a href="#6-指针" class="headerlink" title="6 指针"></a>6 指针</h1><h2 id="6-1-运算符-amp"><a href="#6-1-运算符-amp" class="headerlink" title="6.1 运算符&amp;"></a>6.1 运算符&amp;</h2><ul><li><code>scanf(&quot;%d&quot;, &amp;i)</code>里的&amp;</li><li>获得变量的地址，它的操作数必须是<strong>变量</strong><ul><li><code>int i; printf(&quot;%x&quot;, &amp;i);</code></li></ul></li><li>地址的大小是否与int相同取决于编译器<ul><li><code>int i; printf(&quot;%p&quot;, &amp;i);</code></li></ul></li><li>&amp;不能对没有地址的东西取地址<ul><li>&amp;(a+b)?</li><li>&amp;(a++)?</li><li>&amp;(++a)?</li></ul></li></ul><h2 id="6-2-scanf"><a href="#6-2-scanf" class="headerlink" title="6.2 scanf"></a>6.2 scanf</h2><ul><li>如果能够将取得的变量额地址传递给一个函数，能否通过这个地址在那个函数内访问这个变量？<ul><li><code>scanf(&quot;%d&quot;, &amp;i);</code></li></ul></li><li>scanf()的原型应该是怎样的？我们需要一个参数能保存别的变量的地址，如何表达能够保存地址的变量？</li></ul><h2 id="6-3-指针变量"><a href="#6-3-指针变量" class="headerlink" title="6.3 指针变量"></a>6.3 指针变量</h2><ul><li>变量的值是内存的地址<ul><li>普通变量的值是<strong>实际的值</strong></li><li>指针变量的值是<strong>具有实际值的变量的地址</strong></li></ul></li></ul><p><strong>作为参数的指针</strong></p><ul><li><code>void f(int *p);</code></li><li>在被调用的时候得到了某个变量的地址；<ul><li><code>int i=0;f(&amp;i);</code></li></ul></li><li>在函数里面可以通过这个指针访问外面的这个i</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> k)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;i=%p\n&quot;</span>, &amp;i);</span><br><span class="line">    f(&amp;i);</span><br><span class="line">    g(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; p=%p\n&quot;</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;k=%d\n&quot;</span>,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问那个地址上的变量</strong>*</p><ul><li>*是一个单目运算符，用来访问指针的值所表示地址上的变量</li><li>可以做右值也可以做左值<ul><li><code>int k=*p;</code></li><li><code>*p = k+1;</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *p)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; p=%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);</span><br><span class="line">    *p = <span class="number">26</span>;<span class="comment">// *p代表i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-指针的使用"><a href="#6-4-指针的使用" class="headerlink" title="6.4 指针的使用"></a>6.4 指针的使用</h2><h3 id="6-4-1-场景一"><a href="#6-4-1-场景一" class="headerlink" title="6.4.1 场景一"></a>6.4.1 场景一</h3><ul><li>交换两个变量的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *pa, <span class="type">int</span> *pb)</span>&#123;</span><br><span class="line">    <span class="type">int</span> t = *pa;</span><br><span class="line">    *pa = *pb;</span><br><span class="line">    *pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-2-场景二"><a href="#6-4-2-场景二" class="headerlink" title="6.4.2 场景二"></a>6.4.2 场景二</h3><ul><li>函数返回<strong>多个值</strong>，某些值就只能<strong>通过指针返回</strong><ul><li>传入的参数实际上是需要保存带回的结果的变量</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> min,max;</span><br><span class="line">    minmax(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), &amp;min, &amp;max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d,max=%d\n&quot;</span>,min, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    *min = *max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line">            *min = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line">            *max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数返回<strong>运算的状态</strong>，结果通过指针返回</li><li>常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错：<ul><li>-1或0（在文件操作会看到大量的例子）</li></ul></li><li>但是当任何数值都是有效的可能结果时，就得分开返回了<ul><li><strong>状态使用return返回，实际的值通过指针参数返回</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   @return 如果除法成功，返回1；否则返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">if</span>(divide(a, b, &amp;c))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d/%d=%d\n&quot;</span>, a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> *result)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == b) ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *result = a/b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-指针与数组"><a href="#6-5-指针与数组" class="headerlink" title="6.5 指针与数组"></a>6.5 指针与数组</h2><p>传入函数的数组成了什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> min,max;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main sizeof(a)=%lu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main a=%p\n&quot;</span>, a);</span><br><span class="line">    minmax(a, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), &amp;min, &amp;max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a[0]=%d\n&quot;</span>, a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d,max=%d\n&quot;</span>,min, max);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *p = &amp;min;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\n&quot;</span>, *p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p[0]=%d\n&quot;</span>, p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*a=%d\n&quot;</span>, *a);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a)=%lu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax a=%p\n&quot;</span>, a);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">    *min = *max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line">            *min = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line">            *max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">minmax</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> len, <span class="type">int</span> *max, <span class="type">int</span> *min)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax sizeof(a)=%lu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;minmax a=%p\n&quot;</span>, a);</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1000</span>;</span><br><span class="line">    *min = *max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; *min)&#123;</span><br><span class="line">            *min = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; *max)&#123;</span><br><span class="line">            *max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数参数表中的数组实际上是<strong>指针</strong><ul><li><code>sizeof(a) == sizeof(int*)</code></li><li>但是可以用数组的运算符[]进行计算</li></ul></li><li>以下四种函数原型是等价的：<ul><li><code>int sum(int *ar, int n);</code></li><li><code>int sum(int *, int);</code></li><li><code>int sum(int ar[], int n);</code></li><li><code>int sum(int [], int);</code></li></ul></li></ul><p><strong>数组变量是特殊的指针</strong></p><ul><li>数组变量本身表达地址，所以<ul><li><code>int a[10];int *p=a;</code>&#x2F;&#x2F;无需用&amp;取地址</li><li>但是<strong>数组的单元</strong>表达的是变量，需要用&amp;取地址</li><li><code>a == &amp;a[0]</code></li></ul></li><li>[]运算符可以对数组做，也可以对指针做<ul><li><code>p[0]&lt;==&gt;a[0]</code></li></ul></li><li>*运算符可以对指针做，也可以对数组做<ul><li><code>*a = 25;</code></li></ul></li><li>数组变量是const的指针，所以两个数组之间不能被赋值<ul><li><code>int a[] &lt;==&gt; int *const a=...</code></li></ul></li></ul><h2 id="6-6-指针与const"><a href="#6-6-指针与const" class="headerlink" title="6.6 指针与const"></a>6.6 指针与const</h2><h3 id="6-6-1-指针是const"><a href="#6-6-1-指针是const" class="headerlink" title="6.6.1 指针是const"></a>6.6.1 指针是const</h3><ul><li>表示一旦得到了某个变量的地址，不能再指向其他变量<ul><li><code>int *const q=&amp;i; //q是const</code></li><li><code>*q=26;  //OK</code></li><li><code>q++;   //ERROR</code></li></ul></li></ul><h3 id="6-6-2-所指是const"><a href="#6-6-2-所指是const" class="headerlink" title="6.6.2 所指是const"></a>6.6.2 所指是const</h3><ul><li>表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）<ul><li><code>const int *p=&amp;i;</code></li><li><code>*p=26;  //ERROR!(*P)是cosnt</code></li><li><code>i=26;  //OK </code></li><li><code>p=&amp;j; //OK</code></li></ul></li></ul><p><code>int i;</code></p><p><code>const int *p1=&amp;i;</code></p><p><code>int const *p2=&amp;i</code></p><p><code>int *const p3=&amp;i</code></p><p>判断哪个被const了的标志是const在<em>的前面还是后面*<em>（前面：指针所指的值不能被修改；后面：指针不能被修改）</em></em></p><h3 id="6-6-3-转换"><a href="#6-6-3-转换" class="headerlink" title="6.6.3 转换"></a>6.6.3 转换</h3><ul><li><p>总是可以把一个非const的值转换成const的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *x)</span>;<span class="comment">//在函数内部不会动指针所指的值</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">15</span>;</span><br><span class="line">f(&amp;a);  <span class="comment">//OK</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a;</span><br><span class="line"></span><br><span class="line">f(&amp;b);  <span class="comment">//OK</span></span><br><span class="line">b = a + <span class="number">1</span>; <span class="comment">//ERROR!</span></span><br></pre></td></tr></table></figure></li><li><p>当要传递的参数的类型比地址大的时候，这是常用的手段：既能用比较少的字节数传递值给参数，又能避免函数对外面的变量的修改</p></li></ul><h3 id="6-6-4-const数组"><a href="#6-6-4-const数组" class="headerlink" title="6.6.4 const数组"></a>6.6.4 const数组</h3><ul><li><code>const int a[]=&#123;1,2,3,4,5,6,&#125;;</code></li><li>数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int</li><li>所以<strong>必须通过初始化进行赋值</strong></li></ul><h3 id="6-6-5-保护数组值"><a href="#6-6-5-保护数组值" class="headerlink" title="6.6.5 保护数组值"></a>6.6.5 保护数组值</h3><ul><li>因为把数组传入函数时传递的是<strong>地址</strong>，所以那个函数内部可以修改数组的值</li><li>为了保护数组不被函数破坏，可以设置参数为const<ul><li><code>int sum(cosnt int a[], int length);</code></li></ul></li></ul><h2 id="6-7-指针运算"><a href="#6-7-指针运算" class="headerlink" title="6.7 指针运算"></a>6.7 指针运算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> ac[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,&#125;;</span><br><span class="line">    <span class="type">char</span> *p = ac;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p =%p\n&quot;</span>, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p+1=%p\n&quot;</span>, p+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ai[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> *q = ai;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;q =%p\n&quot;</span>, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;q+1=%p\n&quot;</span>, q+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-8-动态内存分配"><a href="#6-8-动态内存分配" class="headerlink" title="6.8 动态内存分配"></a>6.8 动态内存分配</h2><h1 id="7-字符串"><a href="#7-字符串" class="headerlink" title="7 字符串"></a>7 字符串</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
